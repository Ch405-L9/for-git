Revised Master Prompt (Improved Version)

Below is the updated master prompt for the AI site generator, with enhancements in format and content. Changes include explicit generation of all sections (Hero, Services, Contact, Footer), alignment with locked file structure (fonts/icons directories), and reinforced constraints for performance and accessibility. This prompt should be copied in full when initiating a new site build:

Title: CH405 Master Prompt – Vite/React Site Generator (Revised)
Updated: October 25, 2025

Instruction: You are an AI expert developer. Translate high-level specs into a complete, production-ready website generator. Use the Vite + React + TypeScript stack and follow the exact steps and constraints below. (Ensure all output adheres to the locked best practices – any deviation is not allowed.)

STEP 1 – Design Style Research

Either ask the user BEFORE proceeding with the development of the .py what style he would like from the earch the web for a [STYLE_TYPE] web design agency site (e.g. “minimalist design agency 2025”, “modern SaaS website 2025”). Identify 2–3 reference examples. From these, extract the key design attributes:

Color scheme (primary/background colors)

Typography styles (font family, weights, spacing)

Layout and spacing (section padding, use of grids)

Button and CTA style (shape, hover effects)

Navigation design patterns (menu style, fixed vs. scroll)

Why: This ensures our generated site has a contemporary look consistent with the chosen style.

STEP 2 – Architecture Review (Reference Codebase)

Review the following GitHub repository (my base project) to learn the architectural patterns:

Repo: universal-header-v4 (GitHub link provided)
Focus on:

Build scripts (*.sh files) – to replicate any setup or build steps

Config files (vite.config.ts, tsconfig.json, package.json) – to match dependencies and settings

Component structure (folder and file naming conventions)

Styling approach – how global styles and design tokens are handled (e.g. CSS variables, utility classes)

From this analysis, adopt the same project structure and configuration patterns in our output. All generated code must align with the conventions in my repo.

STEP 3 – CLI Project Generator

Now, create a Python CLI script (generate_site.py) that will produce the entire website project. The script should:

Accept a project name as an argument (e.g. python3 generate_site.py my-website).

Initialize a new Vite + React + TypeScript project without using any interactive prompts (do not use npm create vite, create the structure programmatically).

Generate a package.json with the exact dependencies and devDependencies needed (React, ReactDOM, TypeScript, ESLint, Vite, and the performance plugins).

Include essential config files: vite.config.ts, tsconfig.json, tsconfig.node.json, and a basic index.html.

Run npm install (or pnpm install) automatically after file generation to fetch dependencies. This makes the project immediately runnable.

The script must run non-interactively from start to finish (one command setup). All file writes should be done in code (no template files on disk).

STEP 4 – Generate Components & Sections

Within the script, generate React functional components for the main sections of the site, applying the design style from Step 1 and structure from Step 2. Create the following components in the src/components directory:

Header (layout/Header.tsx): A responsive navigation header at the top of the page. Include the company name (from config) on the left and a nav menu on the right. The nav should have links (anchors) to each section on the page (e.g. “Services”, “Contact”, etc.), using IDs to scroll. Use a simple, clean style (inspired by references) – e.g. a minimal transparent background or a thin bottom border for separation. Ensure the header is accessible: use semantic <nav> and <a> elements, and ensure good contrast for text links.

Hero (sections/Hero.tsx): A bold hero section as the homepage banner. This should fill the viewport initially (e.g. min-height ~70–90vh) with a centered call-to-action. Include an <h1> heading (using the company tagline from config) and a short descriptive <p> text (company description). Add 1–2 CTA buttons, for example “View Services” (scrolls to Services section) and “Contact Us” (scrolls to Contact). Style this section according to the chosen design (Step 1) – e.g. large font for the headline, proper font weight, and perhaps a striking background image. If using a background image, use a Cloudinary URL (see Step 7) and CSS background-image so it’s optimized. All text must be legible – use overlay or contrast as needed for accessibility
imensosoftware.com
.

Services (sections/Services.tsx): A section highlighting the key services or features of the company. This section should have an id of "services" so that the Header links and hero buttons can scroll to it. Include a subheading (e.g. <h2>Our Services</h2>) and a layout of service cards or columns. For example, list 3 main services with an icon or image for each, a service name, and a one-line description. Use a responsive grid or flexbox layout – on desktop, three columns; on mobile, stack vertically (ensure the layout is mobile-friendly
imensosoftware.com
). Use icons/images for visual appeal: e.g. small illustrative images fetched from Cloudinary (see Step 7 for placeholders). Important: For any images used, provide appropriate alt text describing the image (to meet accessibility guidelines
imensosoftware.com
). The design should be consistent with the overall style (colors, typography). If the [STYLE_TYPE] references have specific design elements (e.g. card shadows, hover effects), apply them here. Note: If no “services” are applicable (for a given style or project type), this section can be repurposed as a “Features” or “Portfolio” section – the structure (heading + grid items) remains similar.

Contact (sections/Contact.tsx): A contact section with a simple contact info display (and ready to extend to a form in the future). Include a heading like “Contact Us” and provide contact details from the config (email address and phone number). Format these with labels (e.g. “Email:” followed by a mailto link, and “Phone:” followed by a tel link). Additionally, this section could include a simple contact form (Name, Email, Message fields) if within scope – but at minimum provide the contact links. Make sure the section has an id "contact" and that it’s linked in the Header nav. Keep the design consistent (e.g. if the theme uses accent color for buttons, apply it to a “Send Message” button if a form is included). Ensure the form (or links) are accessible: labels for inputs, focus states, etc. The section should have a top border or spacing to clearly separate it from the previous content.

Footer (layout/Footer.tsx): A persistent footer to appear at the bottom of every page. This can be a simple component inserted below the Contact section. Include elements like: company name or logo, copyright notice, and a few key links (privacy policy, terms, or social media icons). The footer style should complement the design (e.g. smaller font, muted colors). Ensure the text has sufficient contrast and that any icons have accessible labels if they are links. Note: The footer content can be minimal placeholder text for now (it’s mainly to ensure the structure exists). The footer should be included in the App layout so it renders on the page.

Each component should be written as a self-contained React component (e.g. export const Hero = () => { ... }). Use the design tokens from Step 1 (colors, fonts) in styling these components – this can be via inline styles, CSS classes, or CSS variables defined in the global stylesheet (see Step 5). Favor responsive units (like clamp() or percentages) for font sizes and spacing so the site looks good on all devices. Do not hard-code any content that should come from config (use the siteConfig for text like company name, tagline, contact info, etc., by importing it).

STEP 5 – Global Styling (fonts.css & base styles)

Create a global CSS file src/styles/fonts.css that defines project-wide styles, including typography and any custom CSS variables. This file should include:

Font Faces: Use the provided font files (to be placed in public/fonts/). For example, if using the “C059” font (a serif font) as per our standard, include @font-face declarations for the regular (400), bold (700), and italic (400 italic) variants. Use font-display: swap; in each @font-face so text remains visible during load. Assign these fonts a family name (e.g. "C059") and fallbacks (e.g. serif). If [STYLE_TYPE] suggests a different font, you can adjust accordingly, but prefer using self-hosted fonts with WOFF2 files.

CSS Variables: Define CSS variables for key design tokens, for example: --color-bg, --color-text, --color-primary, and --font-family-base or similar. Base these on the design research (Step 1). For instance, set --color-bg to the main background color, --color-text to the main text color (ensuring contrast), etc. Also define --font-primary (set to our custom font family) and perhaps --font-secondary if needed. These variables can then be used in components for consistency.

Base Styles: Include some global styles such as: a reset or normalize (if not using a library, a simple margin/padding reset for body, etc.), and classes for common elements. For example, define a .container class for a max-width wrapper (as used in the components), a .btn class for buttons (and maybe a .btn-primary variant for the primary CTA style). Use the colors and typography variables here (e.g. .btn-primary { background: var(--color-primary); color: #fff; }). Also, ensure interactive elements have focus styles for accessibility (e.g. :focus { outline: 2px solid var(--color-primary); outline-offset: 2px; }).

This CSS file should be imported into the React App (e.g. in App.tsx or main.tsx) so that it applies globally. The goal is to encapsulate the site’s visual identity (fonts, colors, spacing standards) in one place.

STEP 6 – Asset Pipeline & Structure (Locked-in)

Set up the project folder structure and asset handling exactly as follows (this structure is non-negotiable for all builds):

project-name/
├── public/
│   ├── fonts/        # All font files here (WOFF2 format only)
│   ├── icons/        # All SVG icon files here (no raster images)
│   ├── logo.svg      # Company logo (placeholder if not provided)
│   ├── favicon.ico   # Favicon
│   └── robots.txt    # Standard robots.txt
├── src/
│   ├── components/
│   │   ├── layout/
│   │   │   ├── Header.tsx
│   │   │   └── Footer.tsx
│   │   └── sections/
│   │       ├── Hero.tsx
│   │       ├── Services.tsx
│   │       └── Contact.tsx
│   ├── config/
│   │   ├── site.ts       # Site configuration (company info)
│   │   └── cloudinary.ts # Cloudinary config for images
│   ├── styles/
│   │   └── fonts.css     # Global CSS as defined in Step 5
│   ├── App.tsx
│   ├── main.tsx
│   └── vite-env.d.ts
├── package.json
├── vite.config.ts
├── tsconfig.json
├── tsconfig.node.json
└── README.md


Asset Rules:

Fonts: Always place font files under public/fonts/ (as .woff2). Do not import external Google Fonts or use TTF/OTF in production. WOFF2 is required for its smaller size and broad support. The fonts will be preloaded for performance. Use the font faces defined in Step 5 to load them.

Icons: All icons (SVG format) go under public/icons/. Include at least the core UI icons (menu, phone, mail, etc.) and social media icons as needed. These can be provided as placeholders (for example, you might include a few generic SVGs or instruct the user to add their own). The key is the folder exists and is referenced for any <img src="/icons/xyz.svg" /> in the components.

Images: Large images should NOT be in the repo. For any sizable images (hero banners, gallery photos, team headshots, etc.), use Cloudinary or another CDN to host them. In our generator, we will still create a cloudinary.ts config with sample URLs (see Step 7). The idea is to keep the local project lightweight and let the CDN handle image delivery (with optimization like WebP/AVIF conversion). The only images in /public/ should be small assets (SVGs, favicon, maybe a small logo).

By enforcing this structure, we ensure fast builds and deployments (no heavy assets) and a consistent workflow (e.g. adding new icons or fonts later is straightforward).

(We will also create a temporary BASE folder in the generated output with a README instructing the developer to drop their actual asset files (fonts, icons, etc.) there and then move them to the proper locations. This is a convenience to ensure nothing is missed.)

STEP 7 – Configuration Files

Generate the following config files with appropriate content:

src/config/site.ts: an exported object siteConfig containing key site information. Include fields for name (company/site name), tagline (hero text), description (a brief description for hero or metadata), contact (with email and phone subfields), and social (links for GitHub, LinkedIn, Twitter, etc.). Populate this with placeholder data for now (e.g. name: "BADGRTech", tagline: "YOUR BOLD HERO TEXT", etc.). This makes it easy to customize the site’s content by editing one file. The components will import from siteConfig instead of hardcoding text.

src/config/cloudinary.ts: a configuration module for Cloudinary image usage. Define a constant for the Cloudinary cloud name (placeholder "YOUR_CLOUD_NAME" to be replaced by user). Include helper functions to construct URLs and srcsets for images. For example, provide a function getCloudinaryUrl(publicId, preset) that returns a full URL for an image with certain transformations, and a getCloudinarySrcset(publicId) for responsive srcset generation (especially for the hero image). Also, you can include a showcasePlaceholders object mapping keys (like 'hero', 'service1', 'about', etc.) to example Unsplash image URLs fetched via Cloudinary’s API (as the current script does). This file essentially centralizes image links, so if the user wants to replace an image, they do it here.

Other configs: Generate vite.config.ts with the necessary plugins and optimizations (as gleaned from the reference repo). Specifically, include the React plugin, gzip compression plugin (vite-plugin-compression) with a threshold ~10KB, the rollup visualizer plugin, and Terser minification settings to drop console/debugger. Ensure the build target is ES2015 and code-splitting is enabled for vendor chunk. Also, in index.html, include a meta description (use the site description from config) and preload hints for the fonts and maybe a <link rel="preconnect" to the Cloudinary CDN domain for performance. Create a robots.txt in public/ that allows all and points to a sitemap (placeholder URL). These files are important for performance and SEO, and match our locked best practices.

Finally, produce a README.md in the project root that briefly explains how to run the project and reiterates the asset requirements. For example, list the required font and icon files that the user should add, and note the Lighthouse performance target (90+ scores) and how it’s achieved (WOFF2 fonts, CDN images, etc.). This README helps new developers quickly understand how to use the generated project.

STEP 8 – Performance & Quality Assurance

Ensure the generated project meets the following critical requirements (do NOT skip any – these are mandatory):

✅ Non-interactive Build: The script runs to completion on a single command with no prompts (suitable for CI or one-shot use).

✅ Correct Structure & Files: All files and folders exactly match the structure listed in Step 6 (this is locked-in standard).

✅ High Lighthouse Scores: The output is production-ready with target Lighthouse scores of 90+ (Performance, SEO) and 95+ (Accessibility, Best Practices). Achieve this through the optimizations we included: preloading fonts, using font-display: swap to avoid FOIT (flash of invisible text), efficient images via Cloudinary, minified code, etc.

✅ Responsive & Accessible: Follow WCAG 2.1 Level AA guidelines – e.g. sufficient color contrast, alt text on images, focusable controls – so the site is usable by all
imensosoftware.com
imensosoftware.com
. All layout is mobile-friendly (use flex or grid, avoid absolute positioning that could break on small screens).

✅ Match Repo Patterns: Use the same coding patterns as in my repo (naming, hooks, etc.) to ensure consistency. The idea is someone can switch between the generated project and the base repo and find the structure familiar.

✅ No Quality Regressions: The site should load fast and without errors. Include the necessary ESLint and TypeScript settings to catch problems (as seen in the reference), and test that running npm run dev brings up the site with no console errors.

If any instruction in Steps 1–7 conflicts with these critical requirements, defer to the critical requirements and highlight the issue (we must prioritize performance/accessibility over a fancy design request). For example, if a reference site uses an image-heavy auto-playing carousel that would hurt performance, do not implement that – instead, maybe use a lightweight alternative or note the trade-off.

Variables to replace: When using this prompt for a real run, make sure to specify:

[STYLE_TYPE] – the design style or theme (e.g. minimalist, corporate, creative, ultra-modern)

GitHub repo link – if it differs from the one given (for Step 2)

Cloudinary cloud name – if you have one, provide it so the cloudinary.ts can be tailored. Otherwise, use placeholders as described.

Example Usage: (for a quick test)

I need a **minimalist** style site generator using the above prompt.

Style reference: minimalist agency websites 2025
GitHub reference: https://github.com/Ch405-L9/universal-header-v4/... (using provided commit)
Cloudinary cloud name: dsxpcwjwb  (for image URLs)


(The AI should output the complete generate_site.py code based on the prompt.)

Final Output Expectations: The AI’s answer should be a single Python file that, when saved and run, creates a new folder with the structure and files listed. For clarity, here is what the generated project structure should look like (recap from Step 6):

project-name/
├── public/
│   ├── fonts/
│   │   ├── <font-regular>.woff2
│   │   ├── <font-bold>.woff2
│   │   └── <font-italic>.woff2
│   ├── icons/
│   │   └── [... SVG files ...]
│   ├── logo.svg
│   ├── favicon.ico
│   └── robots.txt
├── src/
│   ├── components/
│   │   ├── layout/
│   │   │   ├── Header.tsx
│   │   │   └── Footer.tsx
│   │   └── sections/
│   │       ├── Hero.tsx
│   │       ├── Services.tsx
│   │       └── Contact.tsx
│   ├── config/
│   │   ├── site.ts
│   │   └── cloudinary.ts
│   ├── styles/
│   │   └── fonts.css
│   ├── App.tsx
│   ├── main.tsx
│   └── vite-env.d.ts
├── package.json
├── vite.config.ts
├── tsconfig.json
├── tsconfig.node.json
└── README.md


(The file contents will reflect the design style chosen, but the overall layout and naming should be exactly as above.)

By implementing the above revised prompt, we improve the reliability (cover all needed sections), adherence to standards, and maintain the speed and quality of the generated output. Next, we will address how to extend and customize the site further using additional prompts.
